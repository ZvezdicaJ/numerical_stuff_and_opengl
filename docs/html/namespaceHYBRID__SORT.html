<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Geometrical objects: HYBRID_SORT Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Geometrical objects
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">HYBRID_SORT Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac7b73df60799b21d3451aa838627d881"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7b73df60799b21d3451aa838627d881"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceHYBRID__SORT.html#ac7b73df60799b21d3451aa838627d881">swap</a> (T *a, T *b)</td></tr>
<tr class="memdesc:ac7b73df60799b21d3451aa838627d881"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function just swaps to values based on the pointers provided.  <a href="#ac7b73df60799b21d3451aa838627d881">More...</a><br /></td></tr>
<tr class="separator:ac7b73df60799b21d3451aa838627d881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368e263837d7996212a20d788d9e85ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a368e263837d7996212a20d788d9e85ac"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceHYBRID__SORT.html#a368e263837d7996212a20d788d9e85ac">scalar_partition</a> (T *arr, int low, int high)</td></tr>
<tr class="memdesc:a368e263837d7996212a20d788d9e85ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition function for scalar quick sort algorithm.  <a href="#a368e263837d7996212a20d788d9e85ac">More...</a><br /></td></tr>
<tr class="separator:a368e263837d7996212a20d788d9e85ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cac879f3750d9b5213463f07a4a1b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70cac879f3750d9b5213463f07a4a1b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceHYBRID__SORT.html#a70cac879f3750d9b5213463f07a4a1b1">scalar_QS</a> (T *arr, int low, int high)</td></tr>
<tr class="memdesc:a70cac879f3750d9b5213463f07a4a1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main function that implements scalar QuickSort.  <a href="#a70cac879f3750d9b5213463f07a4a1b1">More...</a><br /></td></tr>
<tr class="separator:a70cac879f3750d9b5213463f07a4a1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa822314eab01e2f91b0131e98fbd638b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHYBRID__SORT.html#aa822314eab01e2f91b0131e98fbd638b">print_aligned_vector</a> (<a class="el" href="type__definitions_8hpp.html#a087efd587d66b881646ef378f1919c90">aligned_vector</a>&lt; float &gt; vec, std::string str)</td></tr>
<tr class="separator:aa822314eab01e2f91b0131e98fbd638b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f76d2e085c5ce3b1aac2200c1f42b7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHYBRID__SORT.html#a5f76d2e085c5ce3b1aac2200c1f42b7b">bitonic_merge_8n</a> (float *array, int startA, int endA, int endB)</td></tr>
<tr class="memdesc:a5f76d2e085c5ce3b1aac2200c1f42b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function merges ordered arrays  <a href="#a5f76d2e085c5ce3b1aac2200c1f42b7b">More...</a><br /></td></tr>
<tr class="separator:a5f76d2e085c5ce3b1aac2200c1f42b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bac6bc8803474e11924ceb1bc74e1ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHYBRID__SORT.html#a3bac6bc8803474e11924ceb1bc74e1ab">hybrid_sort_8n</a> (<a class="el" href="type__definitions_8hpp.html#a087efd587d66b881646ef378f1919c90">aligned_vector</a>&lt; float &gt; &amp;vec, int start, int end)</td></tr>
<tr class="memdesc:a3bac6bc8803474e11924ceb1bc74e1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybrid sort function which sorts arrays containing 8n elements.  <a href="#a3bac6bc8803474e11924ceb1bc74e1ab">More...</a><br /></td></tr>
<tr class="separator:a3bac6bc8803474e11924ceb1bc74e1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a55558c1a67782f1bd0566bb19a185"><td class="memItemLeft" align="right" valign="top">__m256&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHYBRID__SORT.html#ae0a55558c1a67782f1bd0566bb19a185">compress256</a> (__m256 src, unsigned int mask)</td></tr>
<tr class="memdesc:ae0a55558c1a67782f1bd0566bb19a185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function compresses 256 vector towards the lower half (lower elements) based on a provided mask.  more details on <a href="https://stackoverflow.com/questions/36932240/avx2-what-is-the-most-efficient-way-to-pack-left-based-on-a-mask">https://stackoverflow.com/questions/36932240/avx2-what-is-the-most-efficient-way-to-pack-left-based-on-a-mask</a>.  <a href="#ae0a55558c1a67782f1bd0566bb19a185">More...</a><br /></td></tr>
<tr class="separator:ae0a55558c1a67782f1bd0566bb19a185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08b967128fe09cc0a71ec0d908af2eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHYBRID__SORT.html#ad08b967128fe09cc0a71ec0d908af2eb">_mm256_compresstoreu_ps</a> (float *p, unsigned int mask_u32, __m256 vec)</td></tr>
<tr class="memdesc:ad08b967128fe09cc0a71ec0d908af2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function compresses and stores 256 bit register.  <a href="#ad08b967128fe09cc0a71ec0d908af2eb">More...</a><br /></td></tr>
<tr class="separator:ad08b967128fe09cc0a71ec0d908af2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc451064018d2d6b471559c839ae865"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHYBRID__SORT.html#a0fc451064018d2d6b471559c839ae865">simd_partition</a> (float *array, unsigned left, unsigned right)</td></tr>
<tr class="memdesc:a0fc451064018d2d6b471559c839ae865"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classThis.html">This</a> function performs simd partition for quick sort algorithm.  <a href="#a0fc451064018d2d6b471559c839ae865">More...</a><br /></td></tr>
<tr class="separator:a0fc451064018d2d6b471559c839ae865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6705c4bab0c4a4d439364440103a4647"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHYBRID__SORT.html#a6705c4bab0c4a4d439364440103a4647">simd_QS_helper</a> (float *array, unsigned start, unsigned end)</td></tr>
<tr class="memdesc:a6705c4bab0c4a4d439364440103a4647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for sorting vector.  <a href="#a6705c4bab0c4a4d439364440103a4647">More...</a><br /></td></tr>
<tr class="separator:a6705c4bab0c4a4d439364440103a4647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4b9db525ba745c52e4f4add231b28e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHYBRID__SORT.html#a6e4b9db525ba745c52e4f4add231b28e">simd_QS</a> (<a class="el" href="type__definitions_8hpp.html#a087efd587d66b881646ef378f1919c90">aligned_vector</a>&lt; float &gt; &amp;vec, unsigned start, unsigned end)</td></tr>
<tr class="memdesc:a6e4b9db525ba745c52e4f4add231b28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sorts aligned vector of floats.  <a href="#a6e4b9db525ba745c52e4f4add231b28e">More...</a><br /></td></tr>
<tr class="separator:a6e4b9db525ba745c52e4f4add231b28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a08bb817ae8599c88d4e11cc3496d7ed2"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHYBRID__SORT.html#a08bb817ae8599c88d4e11cc3496d7ed2">LOAD</a> = 0xffffffff</td></tr>
<tr class="separator:a08bb817ae8599c88d4e11cc3496d7ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b175b9bd35bd54e294de8488a8acd3"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHYBRID__SORT.html#a84b175b9bd35bd54e294de8488a8acd3">STORE</a> = 0xffffffff</td></tr>
<tr class="separator:a84b175b9bd35bd54e294de8488a8acd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad08b967128fe09cc0a71ec0d908af2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08b967128fe09cc0a71ec0d908af2eb">&#9670;&nbsp;</a></span>_mm256_compresstoreu_ps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HYBRID_SORT::_mm256_compresstoreu_ps </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mask_u32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function compresses and stores 256 bit register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pointer to an array of floats </td></tr>
    <tr><td class="paramname">mask_u32</td><td>32 bit mask according to which the register is compressed </td></tr>
    <tr><td class="paramname">vec</td><td>256 bit register to compress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f76d2e085c5ce3b1aac2200c1f42b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f76d2e085c5ce3b1aac2200c1f42b7b">&#9670;&nbsp;</a></span>bitonic_merge_8n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HYBRID_SORT::bitonic_merge_8n </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function merges ordered arrays </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrayA</td><td>pointer to the start of the array </td></tr>
    <tr><td class="paramname">startA</td><td>index of the first element/vector to be loaded </td></tr>
    <tr><td class="paramname">endA</td><td>index of the last vector to be loaded </td></tr>
    <tr><td class="paramname">endB</td><td>index of the last vector to be loaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0a55558c1a67782f1bd0566bb19a185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a55558c1a67782f1bd0566bb19a185">&#9670;&nbsp;</a></span>compress256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__m256 HYBRID_SORT::compress256 </td>
          <td>(</td>
          <td class="paramtype">__m256&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function compresses 256 vector towards the lower half (lower elements) based on a provided mask.  more details on <a href="https://stackoverflow.com/questions/36932240/avx2-what-is-the-most-efficient-way-to-pack-left-based-on-a-mask">https://stackoverflow.com/questions/36932240/avx2-what-is-the-most-efficient-way-to-pack-left-based-on-a-mask</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>256 bit register to be compressed </td></tr>
    <tr><td class="paramname">mask</td><td>mask according to which the register is compressed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bac6bc8803474e11924ceb1bc74e1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bac6bc8803474e11924ceb1bc74e1ab">&#9670;&nbsp;</a></span>hybrid_sort_8n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HYBRID_SORT::hybrid_sort_8n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="type__definitions_8hpp.html#a087efd587d66b881646ef378f1919c90">aligned_vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hybrid sort function which sorts arrays containing 8n elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>vector to be sorted </td></tr>
    <tr><td class="paramname">start</td><td>index of first element to be sorted </td></tr>
    <tr><td class="paramname">end</td><td>index of the last element to be sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa822314eab01e2f91b0131e98fbd638b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa822314eab01e2f91b0131e98fbd638b">&#9670;&nbsp;</a></span>print_aligned_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HYBRID_SORT::print_aligned_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="type__definitions_8hpp.html#a087efd587d66b881646ef378f1919c90">aligned_vector</a>&lt; float &gt;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a368e263837d7996212a20d788d9e85ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368e263837d7996212a20d788d9e85ac">&#9670;&nbsp;</a></span>scalar_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T HYBRID_SORT::scalar_partition </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition function for scalar quick sort algorithm. </p>
<p><a class="el" href="classThis.html">This</a> function takes last element as pivot, places the pivot element at its correct position in sorted array, and places all smaller (smaller than pivot) to left of pivot and all greater elements to right of pivot. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>pointer to an array of floats </td></tr>
    <tr><td class="paramname">low</td><td>first element to be sorted </td></tr>
    <tr><td class="paramname">high</td><td>last element to be sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70cac879f3750d9b5213463f07a4a1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cac879f3750d9b5213463f07a4a1b1">&#9670;&nbsp;</a></span>scalar_QS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HYBRID_SORT::scalar_QS </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main function that implements scalar QuickSort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>pointer to an array to be sorted </td></tr>
    <tr><td class="paramname">low</td><td>first index to be sorted </td></tr>
    <tr><td class="paramname">high</td><td>last index to be sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fc451064018d2d6b471559c839ae865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc451064018d2d6b471559c839ae865">&#9670;&nbsp;</a></span>simd_partition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned HYBRID_SORT::simd_partition </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classThis.html">This</a> function performs simd partition for quick sort algorithm. </p>
<p>The function is an avx2 implementation of an algorithm from the paper: <a class="el" href="classA.html" title="This class holds vertexes and other data for a circle in xy plane. ">A</a> Novel Hybrid Quicksort Algorithm Vectorized using AVX-512 on Intel Skylake; Author: Berenger Bramas </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to the start of whole array </td></tr>
    <tr><td class="paramname">left</td><td>First index to be sorted </td></tr>
    <tr><td class="paramname">right</td><td>Last index to be sorted - which is also pivot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e4b9db525ba745c52e4f4add231b28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4b9db525ba745c52e4f4add231b28e">&#9670;&nbsp;</a></span>simd_QS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HYBRID_SORT::simd_QS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="type__definitions_8hpp.html#a087efd587d66b881646ef378f1919c90">aligned_vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function sorts aligned vector of floats. </p>
<p>Sorting algorithm is based simd quick sort algorithm presented in <a class="el" href="namespaceHYBRID__SORT.html">HYBRID_SORT</a> FROM PAPER: <a class="el" href="classA.html" title="This class holds vertexes and other data for a circle in xy plane. ">A</a> Novel Hybrid Quicksort Algorithm Vectorized using AVX-512 on Intel Skylake </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>vector to be sorted </td></tr>
    <tr><td class="paramname">start</td><td>index of the first element to be sorted </td></tr>
    <tr><td class="paramname">end</td><td>index of the last element to be sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6705c4bab0c4a4d439364440103a4647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6705c4bab0c4a4d439364440103a4647">&#9670;&nbsp;</a></span>simd_QS_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HYBRID_SORT::simd_QS_helper </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for sorting vector. </p>
<p>Sorting algorithm is based simd quick sort algorithm presented in <a class="el" href="namespaceHYBRID__SORT.html">HYBRID_SORT</a> FROM PAPER: <a class="el" href="classA.html" title="This class holds vertexes and other data for a circle in xy plane. ">A</a> Novel Hybrid Quicksort Algorithm Vectorized using AVX-512 on Intel Skylake </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>pointer to data to be sorted </td></tr>
    <tr><td class="paramname">start</td><td>index of the first element to be sorted </td></tr>
    <tr><td class="paramname">end</td><td>index of the last element to be sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7b73df60799b21d3451aa838627d881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b73df60799b21d3451aa838627d881">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HYBRID_SORT::swap </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function just swaps to values based on the pointers provided. </p>
<p><a class="el" href="classA.html" title="This class holds vertexes and other data for a circle in xy plane. ">A</a> scalar implementation of Quick sort from <a href="https://www.geeksforgeeks.org/quick-sort/@param">https://www.geeksforgeeks.org/quick-sort/@param</a> a pointer to the first element </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>pointer to the second element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a08bb817ae8599c88d4e11cc3496d7ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08bb817ae8599c88d4e11cc3496d7ed2">&#9670;&nbsp;</a></span>LOAD</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int HYBRID_SORT::LOAD = 0xffffffff</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84b175b9bd35bd54e294de8488a8acd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b175b9bd35bd54e294de8488a8acd3">&#9670;&nbsp;</a></span>STORE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int HYBRID_SORT::STORE = 0xffffffff</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
